{"ts":1344749938297,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\n * jQuery UI Nested Sortable\n * v 1.3.5 / 21 jun 2012\n * http://mjsarfatti.com/code/nestedSortable\n *\n * Depends on:\n *\t jquery.ui.sortable.js 1.8+\n *\n * Copyright (c) 2010-2012 Manuele J Sarfatti\n * Licensed under the MIT License\n * http://www.opensource.org/licenses/mit-license.php\n */\n\n(function($) {\n\n\t$.widget(\"mjs.nestedSortable\", $.extend({}, $.ui.sortable.prototype, {\n\n\t\toptions: {\n\t\t\ttabSize: 20,\n\t\t\tdisableNesting: 'mjs-nestedSortable-no-nesting',\n\t\t\terrorClass: 'mjs-nestedSortable-error',\n\t\t\tlistType: 'ol',\n\t\t\tmaxLevels: 0,\n\t\t\tprotectRoot: false,\n\t\t\trootID: null,\n\t\t\trtl: false,\n\t\t\tisAllowed: function(item, parent) { return true; }\n\t\t},\n\n\t\t_create: function() {\n\t\t\tthis.element.data('sortable', this.element.data('nestedSortable'));\n\n\t\t\tif (!this.element.is(this.options.listType))\n\t\t\t\tthrow new Error('nestedSortable: Please check the listType option is set to your actual list type');\n\n\t\t\treturn $.ui.sortable.prototype._create.apply(this, arguments);\n\t\t},\n\n\t\tdestroy: function() {\n\t\t\tthis.element\n\t\t\t\t.removeData(\"nestedSortable\")\n\t\t\t\t.unbind(\".nestedSortable\");\n\t\t\treturn $.ui.sortable.prototype.destroy.apply(this, arguments);\n\t\t},\n\n\t\t_mouseDrag: function(event) {\n\n\t\t\t//Compute the helpers position\n\t\t\tthis.position = this._generatePosition(event);\n\t\t\tthis.positionAbs = this._convertPositionTo(\"absolute\");\n\n\t\t\tif (!this.lastPositionAbs) {\n\t\t\t\tthis.lastPositionAbs = this.positionAbs;\n\t\t\t}\n\n\t\t\t//Do scrolling\n\t\t\tif(this.options.scroll) {\n\t\t\t\tvar o = this.options, scrolled = false;\n\t\t\t\tif(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML') {\n\n\t\t\t\t\tif((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)\n\t\t\t\t\t\tthis.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;\n\t\t\t\t\telse if(event.pageY - this.overflowOffset.top < o.scrollSensitivity)\n\t\t\t\t\t\tthis.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;\n\n\t\t\t\t\tif((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)\n\t\t\t\t\t\tthis.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;\n\t\t\t\t\telse if(event.pageX - this.overflowOffset.left < o.scrollSensitivity)\n\t\t\t\t\t\tthis.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif(event.pageY - $(document).scrollTop() < o.scrollSensitivity)\n\t\t\t\t\t\tscrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);\n\t\t\t\t\telse if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)\n\t\t\t\t\t\tscrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);\n\n\t\t\t\t\tif(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)\n\t\t\t\t\t\tscrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);\n\t\t\t\t\telse if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)\n\t\t\t\t\t\tscrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);\n\n\t\t\t\t}\n\n\t\t\t\tif(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)\n\t\t\t\t\t$.ui.ddmanager.prepareOffsets(this, event);\n\t\t\t}\n\n\t\t\t//Regenerate the absolute position used for position checks\n\t\t\tthis.positionAbs = this._convertPositionTo(\"absolute\");\n\n      // Find the top offset before rearrangement,\n      var previousTopOffset = this.placeholder.offset().top;\n\n\t\t\t//Set the helper position\n\t\t\tif(!this.options.axis || this.options.axis != \"y\") this.helper[0].style.left = this.position.left+'px';\n\t\t\tif(!this.options.axis || this.options.axis != \"x\") this.helper[0].style.top = this.position.top+'px';\n\n\t\t\t//Rearrange\n\t\t\tfor (var i = this.items.length - 1; i >= 0; i--) {\n\n\t\t\t\t//Cache variables and intersection, continue if no intersection\n\t\t\t\tvar item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item);\n\t\t\t\tif (!intersection) continue;\n\n\t\t\t\tif(itemElement != this.currentItem[0] //cannot intersect with itself\n\t\t\t\t\t&&\tthis.placeholder[intersection == 1 ? \"next\" : \"prev\"]()[0] != itemElement //no useless actions that have been done before\n\t\t\t\t\t&&\t!$.contains(this.placeholder[0], itemElement) //no action if the item moved is the parent of the item checked\n\t\t\t\t\t&& (this.options.type == 'semi-dynamic' ? !$.contains(this.element[0], itemElement) : true)\n\t\t\t\t\t//&& itemElement.parentNode == this.placeholder[0].parentNode // only rearrange items within the same container\n\t\t\t\t) {\n\n\t\t\t\t\t$(itemElement).mouseenter();\n\n\t\t\t\t\tthis.direction = intersection == 1 ? \"down\" : \"up\";\n\n\t\t\t\t\tif (this.options.tolerance == \"pointer\" || this._intersectsWithSides(item)) {\n\t\t\t\t\t\t$(itemElement).mouseleave();\n\t\t\t\t\t\tthis._rearrange(event, item);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Clear emtpy ul's/ol's\n\t\t\t\t\tthis._clearEmpty(itemElement);\n\n\t\t\t\t\tthis._trigger(\"change\", event, this._uiHash());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar parentItem = (this.placeholder[0].parentNode.parentNode &&\n\t\t\t\t\t\t\t $(this.placeholder[0].parentNode.parentNode).closest('.ui-sortable').length)\n\t\t\t\t       \t\t\t? $(this.placeholder[0].parentNode.parentNode)\n\t\t\t\t       \t\t\t: null,\n\t\t\t    level = this._getLevel(this.placeholder),\n\t\t\t    childLevels = this._getChildLevels(this.helper);\n\n      // To find the previous sibling in the list, keep backtracking until we hit a valid list item.\n\t\t\tvar previousItem = this.placeholder[0].previousSibling ? $(this.placeholder[0].previousSibling) : null;\n\t\t\tif (previousItem != null) {\n\t\t\t\twhile (previousItem[0].nodeName.toLowerCase() != 'li' || previousItem[0] == this.currentItem[0] || previousItem[0] == this.helper[0]) {\n\t\t\t\t\tif (previousItem[0].previousSibling) {\n\t\t\t\t\t\tpreviousItem = $(previousItem[0].previousSibling);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpreviousItem = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n      // To find the next sibling in the list, keep stepping forward until we hit a valid list item.\n      var nextItem = this.placeholder[0].nextSibling ? $(this.placeholder[0].nextSibling) : null;\n      if (nextItem != null) {\n        while (nextItem[0].nodeName.toLowerCase() != 'li' || nextItem[0] == this.currentItem[0] || nextItem[0] == this.helper[0]) {\n          if (nextItem[0].nextSibling) {\n            nextItem = $(nextItem[0].nextSibling);\n          } else {\n            nextItem = null;\n            break;\n          }\n        }\n      }\n\n\t\t\tvar newList = document.createElement(o.listType);\n\n\t\t\tthis.beyondMaxLevels = 0;\n\t\t\t\n\t\t\t// If the item is moved to the left, send it to its parent's level unless there are siblings below it.\n\t\t\tif (parentItem != null && nextItem == null &&\n\t\t\t\t\t(o.rtl && (this.positionAbs.left + this.helper.outerWidth() > parentItem.offset().left + parentItem.outerWidth()) ||\n\t\t\t\t\t!o.rtl && (this.positionAbs.left < parentItem.offset().left))) {\n\t\t\t\tparentItem.after(this.placeholder[0]);\n\t\t\t\tthis._clearEmpty(parentItem[0]);\n\t\t\t\tthis._trigger(\"change\", event, this._uiHash());\n\t\t\t}\n\t\t\t// If the item is below a sibling and is moved to the right, make it a child of that sibling.\n\t\t\telse if (previousItem != null &&\n\t\t\t\t\t\t(o.rtl && (this.positionAbs.left + this.helper.outerWidth() < previousItem.offset().left + previousItem.outerWidth() - o.tabSize) ||\n\t\t\t\t\t\t!o.rtl && (this.positionAbs.left > previousItem.offset().left + o.tabSize))) {\n\t\t\t\tthis._isAllowed(previousItem, level, level+childLevels+1);\n\t\t\t\tif (!previousItem.children(o.listType).length) {\n\t\t\t\t\tpreviousItem[0].appendChild(newList);\n\t\t\t\t}\n        // If this item is being moved from the top, add it to the top of the list.\n        if (previousTopOffset && (previousTopOffset <= previousItem.offset().top)) {\n          previousItem.children(o.listType).prepend(this.placeholder);\n        }\n        // Otherwise, add it to the bottom of the list.\n        else {\n\t\t\t\t  previousItem.children(o.listType)[0].appendChild(this.placeholder[0]);\n        }\n\t\t\t\tthis._trigger(\"change\", event, this._uiHash());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis._isAllowed(parentItem, level, level+childLevels);\n\t\t\t}\n\n\t\t\t//Post events to containers\n\t\t\tthis._contactContainers(event);\n\n\t\t\t//Interconnect with droppables\n\t\t\tif($.ui.ddmanager) $.ui.ddmanager.drag(this, event);\n\n\t\t\t//Call callbacks\n\t\t\tthis._trigger('sort', event, this._uiHash());\n\n\t\t\tthis.lastPositionAbs = this.positionAbs;\n\t\t\treturn false;\n\n\t\t},\n\n\t\t_mouseStop: function(event, noPropagation) {\n\n\t\t\t// If the item is in a position not allowed, send it back\n\t\t\tif (this.beyondMaxLevels) {\n\n\t\t\t\tthis.placeholder.removeClass(this.options.errorClass);\n\n\t\t\t\tif (this.domPosition.prev) {\n\t\t\t\t\t$(this.domPosition.prev).after(this.placeholder);\n\t\t\t\t} else {\n\t\t\t\t\t$(this.domPosition.parent).prepend(this.placeholder);\n\t\t\t\t}\n\n\t\t\t\tthis._trigger(\"revert\", event, this._uiHash());\n\n\t\t\t}\n\n\t\t\t// Clean last empty ul/ol\n\t\t\tfor (var i = this.items.length - 1; i >= 0; i--) {\n\t\t\t\tvar item = this.items[i].item[0];\n\t\t\t\tthis._clearEmpty(item);\n\t\t\t}\n\n\t\t\t$.ui.sortable.prototype._mouseStop.apply(this, arguments);\n\n\t\t},\n\n\t\tserialize: function(options) {\n\n\t\t\tvar o = $.extend({}, this.options, options),\n\t\t\t\titems = this._getItemsAsjQuery(o && o.connected),\n\t\t\t    str = [];\n\n\t\t\t$(items).each(function() {\n\t\t\t\tvar res = ($(o.item || this).attr(o.attribute || 'id') || '')\n\t\t\t\t\t\t.match(o.expression || (/(.+)[-=_](.+)/)),\n\t\t\t\t    pid = ($(o.item || this).parent(o.listType)\n\t\t\t\t\t\t.parent(o.items)\n\t\t\t\t\t\t.attr(o.attribute || 'id') || '')\n\t\t\t\t\t\t.match(o.expression || (/(.+)[-=_](.+)/));\n\n\t\t\t\tif (res) {\n\t\t\t\t\tstr.push(((o.key || res[1]) + '[' + (o.key && o.expression ? res[1] : res[2]) + ']')\n\t\t\t\t\t\t+ '='\n\t\t\t\t\t\t+ (pid ? (o.key && o.expression ? pid[1] : pid[2]) : o.rootID));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif(!str.length && o.key) {\n\t\t\t\tstr.push(o.key + '=');\n\t\t\t}\n\n\t\t\treturn str.join('&');\n\n\t\t},\n\n\t\ttoHierarchy: function(options) {\n\n\t\t\tvar o = $.extend({}, this.options, options),\n\t\t\t\tsDepth = o.startDepthCount || 0,\n\t\t\t    ret = [];\n\n\t\t\t$(this.element).children(o.items).each(function () {\n\t\t\t\tvar level = _recursiveItems(this);\n\t\t\t\tret.push(level);\n\t\t\t});\n\n\t\t\treturn ret;\n\n\t\t\tfunction _recursiveItems(item) {\n\t\t\t\tvar id = ($(item).attr(o.attribute || 'id') || '').match(o.expression || (/(.+)[-=_](.+)/));\n\t\t\t\tif (id) {\n\t\t\t\t\tvar currentItem = {\"id\" : id[2]};\n\t\t\t\t\tif ($(item).children(o.listType).children(o.items).length > 0) {\n\t\t\t\t\t\tcurrentItem.children = [];\n\t\t\t\t\t\t$(item).children(o.listType).children(o.items).each(function() {\n\t\t\t\t\t\t\tvar level = _recursiveItems(this);\n\t\t\t\t\t\t\tcurrentItem.children.push(level);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn currentItem;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\ttoArray: function(options) {\n\n\t\t\tvar o = $.extend({}, this.options, options),\n\t\t\t\tsDepth = o.startDepthCount || 0,\n\t\t\t    ret = [],\n\t\t\t    left = 2;\n\n\t\t\tret.push({\n\t\t\t\t\"item_id\": o.rootID,\n\t\t\t\t\"parent_id\": 'none',\n\t\t\t\t\"depth\": sDepth,\n\t\t\t\t\"left\": '1',\n\t\t\t\t\"right\": ($(o.items, this.element).length + 1) * 2\n\t\t\t});\n\n\t\t\t$(this.element).children(o.items).each(function () {\n\t\t\t\tleft = _recursiveArray(this, sDepth + 1, left);\n\t\t\t});\n\n\t\t\tret = ret.sort(function(a,b){ return (a.left - b.left); });\n\n\t\t\treturn ret;\n\n\t\t\tfunction _recursiveArray(item, depth, left) {\n\n\t\t\t\tvar right = left + 1,\n\t\t\t\t    id,\n\t\t\t\t    pid;\n\n\t\t\t\tif ($(item).children(o.listType).children(o.items).length > 0) {\n\t\t\t\t\tdepth ++;\n\t\t\t\t\t$(item).children(o.listType).children(o.items).each(function () {\n\t\t\t\t\t\tright = _recursiveArray($(this), depth, right);\n\t\t\t\t\t});\n\t\t\t\t\tdepth --;\n\t\t\t\t}\n\n\t\t\t\tid = ($(item).attr(o.attribute || 'id')).match(o.expression || (/(.+)[-=_](.+)/));\n\n\t\t\t\tif (depth === sDepth + 1) {\n\t\t\t\t\tpid = o.rootID;\n\t\t\t\t} else {\n\t\t\t\t\tvar parentItem = ($(item).parent(o.listType)\n\t\t\t\t\t\t\t\t\t\t\t .parent(o.items)\n\t\t\t\t\t\t\t\t\t\t\t .attr(o.attribute || 'id'))\n\t\t\t\t\t\t\t\t\t\t\t .match(o.expression || (/(.+)[-=_](.+)/));\n\t\t\t\t\tpid = parentItem[2];\n\t\t\t\t}\n\n\t\t\t\tif (id) {\n\t\t\t\t\t\tret.push({\"item_id\": id[2], \"parent_id\": pid, \"depth\": depth, \"left\": left, \"right\": right});\n\t\t\t\t}\n\n\t\t\t\tleft = right + 1;\n\t\t\t\treturn left;\n\t\t\t}\n\n\t\t},\n\n\t\t_clearEmpty: function(item) {\n\n\t\t\tvar emptyList = $(item).children(this.options.listType);\n\t\t\tif (emptyList.length && !emptyList.children().length) {\n\t\t\t\temptyList.remove();\n\t\t\t}\n\n\t\t},\n\n\t\t_getLevel: function(item) {\n\n\t\t\tvar level = 1;\n\n\t\t\tif (this.options.listType) {\n\t\t\t\tvar list = item.closest(this.options.listType);\n\t\t\t\twhile (list && list.length > 0 && \n                    \t!list.is('.ui-sortable')) {\n\t\t\t\t\tlevel++;\n\t\t\t\t\tlist = list.parent().closest(this.options.listType);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn level;\n\t\t},\n\n\t\t_getChildLevels: function(parent, depth) {\n\t\t\tvar self = this,\n\t\t\t    o = this.options,\n\t\t\t    result = 0;\n\t\t\tdepth = depth || 0;\n\n\t\t\t$(parent).children(o.listType).children(o.items).each(function (index, child) {\n\t\t\t\t\tresult = Math.max(self._getChildLevels(child, depth + 1), result);\n\t\t\t});\n\n\t\t\treturn depth ? result + 1 : result;\n\t\t},\n\n\t\t_isAllowed: function(parentItem, level, levels) {\n\t\t\tvar o = this.options,\n\t\t\t\tisRoot = $(this.domPosition.parent).hasClass('ui-sortable') ? true : false,\n\t\t\t\tmaxLevels = this.placeholder.closest('.ui-sortable').nestedSortable('option', 'maxLevels'); // this takes into account the maxLevels set to the recipient list\n\n\t\t\t// Is the root protected?\n\t\t\t// Are we trying to nest under a no-nest?\n\t\t\t// Are we nesting too deep?\n\t\t\tif (!o.isAllowed(parentItem, this.placeholder) ||\n\t\t\t\tparentItem && parentItem.hasClass(o.disableNesting) ||\n\t\t\t\to.protectRoot && (parentItem == null && !isRoot || isRoot && level > 1)) {\n\t\t\t\t\tthis.placeholder.addClass(o.errorClass);\n\t\t\t\t\tif (maxLevels < levels && maxLevels != 0) {\n\t\t\t\t\t\tthis.beyondMaxLevels = levels - maxLevels;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.beyondMaxLevels = 1;\n\t\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (maxLevels < levels && maxLevels != 0) {\n\t\t\t\t\tthis.placeholder.addClass(o.errorClass);\n\t\t\t\t\tthis.beyondMaxLevels = levels - maxLevels;\n\t\t\t\t} else {\n\t\t\t\t\tthis.placeholder.removeClass(o.errorClass);\n\t\t\t\t\tthis.beyondMaxLevels = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}));\n\n\t$.mjs.nestedSortable.prototype.options = $.extend({}, $.ui.sortable.prototype.options, $.mjs.nestedSortable.prototype.options);\n})(jQuery);"]],"start1":0,"start2":0,"length1":0,"length2":13923}]],"length":13923}
{"contributors":[],"silentsave":false,"ts":1344749990107,"patch":[[{"diffs":[[0," true; }"],[1,",\n//The next two options added for placeholder visibility\n            placeholder: 'placeholder',\n            forcePlaceholderSize: true"],[0,"\n\t\t},\n\n\t"]],"start1":642,"start2":642,"length1":16,"length2":152}]],"length":14059,"saved":false}
